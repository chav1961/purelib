; -------------------------------------------------------------------------
;		Print imports for the class generated 
; -------------------------------------------------------------------------

printImports		.macro	package:str=,ruleEnum:str=
		.if		exists(package)
			.package	&package
		.endif
		.import	chav1961.purelib.basic.interfaces.SyntaxTreeInterface
		.import	chav1961.purelib.basic.CharUtils
		.import	chav1961.purelib.cdb.SyntaxNode
		.import	chav1961.purelib.cdb.interfaces.RuleBasedParser
		.import	chav1961.purelib.cdb.AbstractBNFParser2 protected
		.import	chav1961.purelib.cdb.intern.Predefines
		.import	chav1961.purelib.cdb.intern.BNFParserStack
		.import	java.lang.Integer
		.import	&ruleEnum
		.mend

; -------------------------------------------------------------------------
;		Print header for the parser 
; -------------------------------------------------------------------------

BNFParserHeader		.macro unique:int=,ruleEnum:str=,className:str=
		.if		!exists(className)
			.error		"mandatory parameter 'className' is missing"
		.else
			.source	"&className"
			.line	auto
&className	.class	public extends chav1961.purelib.cdb.AbstractBNFParser2 implements chav1961.purelib.cdb.interfaces.RuleBasedParser  
		.endif
		.mend
		
; -------------------------------------------------------------------------
;		Print header for lexical parser
; -------------------------------------------------------------------------

BNFParserLexHead	.macro unique:int=,className:str=
		.if		!exists(className)
			.error		"mandatory parameter 'className' is missing"
		.else
nextLexema:		.method	int protected
this			.parameter &className final
content			.parameter char[] final
from			.parameter int
				.stack	optimistic
				iload		from
				putfield	prevFrom
				aload		this
				aload		content
				iload		from
				invokevirtual	chav1961.purelib.cdb.AbstractBNFParser2.skipBlank([CI)I
				istore		from
				aload		content
				iload		from
				iaload
		.endif
		.mend

; -------------------------------------------------------------------------
;		Print switch for lexical parser
; -------------------------------------------------------------------------

BNFParserLexSwitch	.macro unique:int=,chars:str[]=
index			.local	int

		.if		!exists(chars)
			.error		"mandatory parameter 'chars' is missing"
		.else
			.tableswitch
				.for	index = 0 to chars.length
					'&chars[index]' : label&index 
				.next
				.default : standard
			.end
		.endif				
		.mend

; -------------------------------------------------------------------------
;		Print switch item for lexical parser 
; -------------------------------------------------------------------------

BNFParserLexSwitchItem	.macro unique:int=,chars:str=,seq:int=
label&seq: 		
		.mend

; -------------------------------------------------------------------------
;		Print default switch item for lexical parser
; -------------------------------------------------------------------------

BNFParserLexSwitchDefault	.macro unique:int=
				aload		this
				aload		content
				iload		from
				invokevirtual	chav1961.purelib.cdb.AbstractBNFParser2.nextLexemaPredef([CI)I
				istore		from
		.mend

; -------------------------------------------------------------------------
;		Print tail for lexical parser
; -------------------------------------------------------------------------

BNFParserLexTail	.macro unique:int=,trace:bool=false
			.if	trace
				aload		this
				aload		content
				iload		from
				invokevirtual	chav1961.purelib.cdb.AbstractBNFParser2.traceLex([CI)V
			.endif
				iload	from
				ireturn
nextLexema:		.end
		.mend
		
; -------------------------------------------------------------------------
;		Print tail for the parser 
; -------------------------------------------------------------------------

BNFParserTail		.macro unique:int=,className:str=		
		.if		!exists(className)
			.error		"mandatory parameter 'className' is missing"
		.else
&className	.end  
		.endif
		.mend
