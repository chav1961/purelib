; -------------------------------------------------------------------------

printImports	.macro
		.import	chav1961.purelib.basic.interfaces.SyntaxTreeInterface
		.import	chav1961.purelib.basic.CharUtils
		.import	chav1961.purelib.cdb.SyntaxNode
		.import	chav1961.purelib.cdb.interfaces.RuleBasedParser
		.import	chav1961.purelib.cdb.AbstractBNFParser protected
		.import	chav1961.purelib.cdb.intern.Predefines
		.import	chav1961.purelib.cdb.intern.BNFParserStack
		.mend

; -------------------------------------------------------------------------

beginClassDeclaration	.macro className:str=
&className	.class	public extends chav1961.purelib.cdb.AbstractBNFParser implements chav1961.purelib.cdb.interfaces.RuleBasedParser  
		.mend

; -------------------------------------------------------------------------

declareSequenceField	.macro className:str=,fieldName:str=
&fieldName	.field		char[] private static final
		.mend

; -------------------------------------------------------------------------

beforeClinit	.macro	className:str=
&className		.method	void static
				.stack	optimistic
		.mend

; -------------------------------------------------------------------------

clinitPrepareSequence	.macro	className:str=,fieldName:str=,value:str=
		ldc				"&value"
		invokevirtual	java.lang.String.toCharArray()[C
		putstatic		&fieldName
		.mend

; -------------------------------------------------------------------------

afterClinit	.macro className:str=
		return
&className		.end
		.mend
; -------------------------------------------------------------------------

prepareConstructor	.macro className:str=
&className		.method		void public
clazz			.parameter	java.lang.Class final
keywords		.parameter	chav1961.purelib.basic.interfaces.SyntaxTreeInterface final
				.stack	optimistic
				aload		this
				dup
				aload		clazz
				aload		keywords
				invokespecial	chav1961.purelib.cdb.AbstractBNFParser.<init>(Ljava/lang/Class;Lchav1961/purelib/basic/interfaces/SyntaxTreeInterface;)V
				return
&className		.end
		.mend

; -------------------------------------------------------------------------

skipBlank		.macro
				aload	content
				iload	from
				ldc		1
				invokestatic chav1961.purelib.basic.CharUtils.skipBlank([CIZ)I
				istore	from	
		.mend

; -------------------------------------------------------------------------

checkpoint		.macro	type:str,message:str="obj="
				ldc			"&message"
				invokestatic chav1961.purelib.cdb.AbstractBNFParser.checkpoint(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;
				checkcast	&type
		.mend

; -------------------------------------------------------------------------

prepareCharTestMethod	.macro className:str=,fieldValue:int=,methodName:str=
&methodName		.method		boolean private static
content			.parameter	char[] final
from			.parameter	int
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack		optimistic
				skipBlank
				aload		content
				iload		from
				caload
				ldc			&fieldValue
				if_icmpeq	trueLabel
				ldc			0
				ireturn
trueLabel:		ldc			1				
				ireturn
&methodName		.end
		.mend

; -------------------------------------------------------------------------

prepareCharSkipMethod	.macro className:str=,fieldValue:int=,methodName:str=
&methodName		.method		int private static
content			.parameter	char[] final
from			.parameter	int
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack		optimistic
				skipBlank
				aload		content
				iload		from
				caload
				ldc			&fieldValue
				if_icmpeq	trueLabel
				aload		content
				iload		from
				ldc			" missing character (&fieldValue)"
				getstatic	chav1961.purelib.cdb.AbstractBNFParser.EMPTY_PARAMETERS
				invokestatic	chav1961.purelib.cdb.AbstractBNFParser.throwSyntaxException([CILjava/lang/String;[Ljava/lang/Object;)V
trueLabel:		iload		from
				ldc			1
				iadd				
				ireturn
&methodName		.end
		.mend

; -------------------------------------------------------------------------

prepareCharParseMethod	.macro className:str=,fieldValue:int=,methodName:str=
&methodName		.method		int private static
content			.parameter	char[] final
from			.parameter	int
names			.parameter	chav1961.purelib.basic.interfaces.SyntaxTreeInterface final
keywords		.parameter	chav1961.purelib.basic.interfaces.SyntaxTreeInterface final
root			.parameter	chav1961.purelib.cdb.SyntaxNode final
stack			.parameter	chav1961.purelib.cdb.intern.BNFParserStack final
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack		optimistic
				skipBlank
				aload		content
				iload		from
				caload
				ldc			&fieldValue
				if_icmpeq	trueLabel
				aload		content
				iload		from
				ldc			" missing character (&fieldValue)"
				getstatic	chav1961.purelib.cdb.AbstractBNFParser.EMPTY_PARAMETERS
				invokestatic	chav1961.purelib.cdb.AbstractBNFParser.throwSyntaxException([CILjava/lang/String;[Ljava/lang/Object;)V
trueLabel:		iload		from
				ldc			1
				iadd				
				ireturn
&methodName		.end
		.mend


; -------------------------------------------------------------------------

prepareSequenceTestMethod	.macro className:str=,fieldName:str=,methodName:str=
&methodName		.method	boolean private static
content			.parameter	char[] final
from			.parameter	int
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack	optimistic
				skipBlank
				aload		content
				iload		from
				getstatic	&fieldName		
				invokestatic	chav1961.purelib.basic.CharUtils.compare([CI[C)Z
				ireturn
&methodName		.end
		.mend

; -------------------------------------------------------------------------

prepareSequenceSkipMethod	.macro className:str=,fieldName:str=,methodName:str=,testMethodName:str=
&methodName		.method	int private static
content			.parameter	char[] final
from			.parameter	int
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack	optimistic
				skipBlank
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&testMethodName([CI[I[J)Z
				ifne		trueLabel
				aload		content
				iload		from
				ldc			" missing sequence (&fieldName)"
				getstatic	chav1961.purelib.cdb.AbstractBNFParser.EMPTY_PARAMETERS
				invokestatic	chav1961.purelib.cdb.AbstractBNFParser.throwSyntaxException([CILjava/lang/String;[Ljava/lang/Object;)V
trueLabel:		getstatic	&fieldName
				arraylength
				iload		from
				iadd				
				ireturn
&methodName		.end
		.mend

; -------------------------------------------------------------------------

prepareSequenceParseMethod	.macro className:str=,fieldName:str=,methodName:str=,testMethodName:str=
&methodName		.method	int private static
content			.parameter	char[] final
from			.parameter	int
names			.parameter	chav1961.purelib.basic.interfaces.SyntaxTreeInterface final
keywords		.parameter	chav1961.purelib.basic.interfaces.SyntaxTreeInterface final
root			.parameter	chav1961.purelib.cdb.SyntaxNode final
stack			.parameter	chav1961.purelib.cdb.intern.BNFParserStack final
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack	optimistic
				skipBlank
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&testMethodName([CI[I[J)Z
				ifne		trueLabel
				aload		content
				iload		from
				ldc			" missing sequence (&fieldName)"
				getstatic	chav1961.purelib.cdb.AbstractBNFParser.EMPTY_PARAMETERS
				invokestatic	chav1961.purelib.cdb.AbstractBNFParser.throwSyntaxException([CILjava/lang/String;[Ljava/lang/Object;)V
trueLabel:		getstatic	&fieldName
				arraylength
				iload		from
				iadd				
				ireturn
&methodName		.end
		.mend

; -------------------------------------------------------------------------

prepareNameTestMethod .macro className:str=,name:int=,methodName:str=,referenceMethodName:str=
&methodName		.method		boolean private static
content			.parameter	char[] final
from			.parameter	int
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack		optimistic
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic &referenceMethodName([CI[I[J)Z
				ireturn
&methodName		.end
		.mend

; -------------------------------------------------------------------------

prepareNameSkipMethod .macro className:str=,name:int=,methodName:str=,referenceMethodName:str=
&methodName		.method		int private static
content			.parameter	char[] final
from			.parameter	int
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack		optimistic
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic &referenceMethodName([CI[I[J)I
				ireturn
&methodName		.end
		.mend

; -------------------------------------------------------------------------

prepareNameParseMethod .macro className:str=,name:int=,methodName:str=,referenceMethodName:str=
&methodName		.method		int private static
content			.parameter	char[] final
from			.parameter	int
root			.parameter	chav1961.purelib.cdb.SyntaxNode final
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack		optimistic
				aload		content
				iload		from
				aload		root
				aload		tempInt
				aload		tempLong
				invokestatic &referenceMethodName([CILchav1961/purelib/cdb/SyntaxNode;[I[J)I
				ireturn
&methodName		.end
		.mend

; -------------------------------------------------------------------------

preparePredefinedTestMethod .macro className:str=,name:str=,methodName:str=
&methodName		.method		boolean private static
content			.parameter	char[] final
from			.parameter	int
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack		optimistic
				aload		content
				iload		from
				getstatic	chav1961.purelib.cdb.intern.Predefines.&name
				aload		tempInt
				aload		tempLong
				invokestatic	chav1961.purelib.cdb.AbstractBNFParser.testPredefined([CILchav1961/purelib/cdb/intern/Predefines;[I[J)Z
				ireturn
&methodName		.end
		.mend

; -------------------------------------------------------------------------

preparePredefinedSkipMethod .macro className:str=,name:str=,methodName:str=
&methodName		.method		int private static
content			.parameter	char[] final
from			.parameter	int
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack		optimistic
				aload		content
				iload		from
				getstatic	chav1961.purelib.cdb.intern.Predefines.&name
				aload		tempInt
				aload		tempLong
				invokestatic	chav1961.purelib.cdb.AbstractBNFParser.skipPredefined([CILchav1961/purelib/cdb/intern/Predefines;[I[J)I
				ireturn
&methodName		.end
		.mend

; -------------------------------------------------------------------------

preparePredefinedParseMethod .macro className:str=,name:str=,methodName:str=
&methodName		.method		int private static
content			.parameter	char[] final
from			.parameter	int
names			.parameter	chav1961.purelib.basic.interfaces.SyntaxTreeInterface final
keywords		.parameter	chav1961.purelib.basic.interfaces.SyntaxTreeInterface final
root			.parameter	chav1961.purelib.cdb.SyntaxNode final
stack			.parameter	chav1961.purelib.cdb.intern.BNFParserStack final 
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack		optimistic
				aload		content
				iload		from
				getstatic	chav1961.purelib.cdb.intern.Predefines.&name
				aload		names
				aload		root
				aload		tempInt
				aload		tempLong
				invokestatic	chav1961.purelib.cdb.AbstractBNFParser.parsePredefined([CILchav1961/purelib/cdb/intern/Predefines;Lchav1961/purelib/basic/interfaces/SyntaxTreeInterface;Lchav1961/purelib/cdb/SyntaxNode;[I[J)I
				ireturn
&methodName		.end
		.mend

; -------------------------------------------------------------------------

prepareOptionTestMethodStart .macro className:str=,methodName:str=
&methodName		.method		boolean private static
content			.parameter	char[] final
from			.parameter	int
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack		optimistic
				ldc			1
				ireturn
&methodName		.end

&methodName.Optional	.method		boolean private static
content			.parameter	char[] final
from			.parameter	int
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack		optimistic
		.mend

; -------------------------------------------------------------------------

prepareOptionTestMethodItem  .macro className:str=,methodName:str=,skipMethodName:str=
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&methodName([CI[I[J)Z
				ifeq		falseLabel
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&skipMethodName([CI[I[J)I
				istore		from
		.mend

; -------------------------------------------------------------------------

prepareOptionTestMethodEnd   .macro className:str=,methodName:str=
				ldc			1
				ireturn
falseLabel:
				ldc			0
				ireturn				
&methodName.Optional	.end
		.mend
		
; -------------------------------------------------------------------------
		
prepareOptionSkipMethodStart .macro className:str=,methodName:str=,testMethodName:str=
&methodName		.method		int private static
content			.parameter	char[] final
from			.parameter	int
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack		optimistic
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&testMethodName.Optional([CI[I[J)Z
				ifeq		falseLabel
		.mend

; -------------------------------------------------------------------------

prepareOptionSkipMethodItem  .macro className:str=,methodName:str=
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&methodName([CI[I[J)I
				istore		from
		.mend

; -------------------------------------------------------------------------

prepareOptionSkipMethodEnd   .macro className:str=,methodName:str=
falseLabel:		iload		from
				ireturn
&methodName		.end
		.mend

; -------------------------------------------------------------------------
		
prepareOptionParseMethodStart .macro className:str=,methodName:str=,testMethodName:str=
&methodName		.method		int private static
content			.parameter	char[] final
from			.parameter	int
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack		optimistic
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&testMethodName.Optional([CI[I[J)Z
				ifeq		falseLabel
		.mend

; -------------------------------------------------------------------------

prepareOptionParseMethodItem  .macro className:str=,methodName:str=
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&methodName([CI[I[J)I
				istore		from
		.mend

; -------------------------------------------------------------------------

prepareOptionParseMethodEnd   .macro className:str=,methodName:str=
falseLabel:		iload		from
				ireturn
&methodName		.end
		.mend

; -------------------------------------------------------------------------

prepareRepeatTestMethodStart .macro className:str=,methodName:str=
&methodName		.method		boolean private static
content			.parameter	char[] final
from			.parameter	int
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack		optimistic
		.mend

; -------------------------------------------------------------------------

prepareRepeatTestMethodItem  .macro className:str=,methodName:str=,skipMethodName:str=
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&methodName([CI[I[J)Z
				ifeq		falseLabel
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&skipMethodName([CI[I[J)I
				istore		from
		.mend

; -------------------------------------------------------------------------

prepareRepeatTestMethodEnd   .macro className:str=,methodName:str=
				ldc			1
				ireturn
falseLabel:		ldc			0
				ireturn				
&methodName		.end
		.mend
		
; -------------------------------------------------------------------------

prepareRepeatSkipMethodStart .macro className:str=,methodName:str=,testMethodName:str=
&methodName		.method		int private static
content			.parameter	char[] final
from			.parameter	int
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack		optimistic
again:			aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&testMethodName([CI[I[J)Z
				ifeq		falseLabel
		.mend

; -------------------------------------------------------------------------

prepareRepeatSkipMethodItem  .macro className:str=,methodName:str=
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&methodName([CI[I[J)I
				istore		from
		.mend

; -------------------------------------------------------------------------

prepareRepeatSkipMethodEnd   .macro className:str=,methodName:str=
				goto		again
falseLabel:		iload		from
				ireturn
&methodName		.end
		.mend

; -------------------------------------------------------------------------

prepareRepeatParseMethodStart .macro className:str=,methodName:str=,testMethodName:str=
&methodName		.method		int private static
content			.parameter	char[] final
from			.parameter	int
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack		optimistic
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&testMethodName.Optional([CI[I[J)Z
				ifeq		falseLabel
		.mend

; -------------------------------------------------------------------------

prepareRepeatParseMethodItem  .macro className:str=,methodName:str=
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&methodName([CI[I[J)I
				istore		from
		.mend

; -------------------------------------------------------------------------

prepareRepeatParseMethodEnd   .macro className:str=,methodName:str=
falseLabel:		iload		from
				ireturn
&methodName		.end
		.mend


; -------------------------------------------------------------------------

prepareSwitchTestMethodStart .macro className:str=,methodName:str=
&methodName		.method		boolean private static
content			.parameter	char[] final
from			.parameter	int
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack		optimistic
		.mend

; -------------------------------------------------------------------------

prepareSwitchTestMethodItem  .macro className:str=,methodName:str=
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&methodName([CI[I[J)Z
				ifne		trueLabel
		.mend

; -------------------------------------------------------------------------

prepareSwitchTestMethodEnd   .macro className:str=,methodName:str=
				ldc			0
				ireturn
trueLabel:		ldc			1
				ireturn				
&methodName		.end
		.mend

; -------------------------------------------------------------------------

prepareSwitchSkipMethodStart .macro className:str=,methodName:str=,testMethodName:str=
&methodName		.method		int private static
content			.parameter	char[] final
from			.parameter	int
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack		optimistic
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&testMethodName([CI[I[J)Z
				ifeq		falseLabel
		.mend

; -------------------------------------------------------------------------

prepareSwitchSkipMethodItem  .macro className:str=,methodName:str=,testMethodName:str=
localLabel		.local		int
localLabel		.set		uniqueG()
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&testMethodName([CI[I[J)Z
				ifeq		falseLabel&localLabel
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&methodName([CI[I[J)I
				goto		exit
falseLabel&localLabel:				
		.mend

; -------------------------------------------------------------------------

prepareSwitchSkipMethodEnd   .macro className:str=,methodName:str=
falseLabel:		iload		from
exit:			ireturn
&methodName		.end
		.mend

; -------------------------------------------------------------------------

prepareSwitchParseMethodStart .macro className:str=,methodName:str=,testMethodName:str=
&methodName		.method		int private static
content			.parameter	char[] final
from			.parameter	int
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack		optimistic
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&testMethodName([CI[I[J)Z
				ifeq		falseLabel
		.mend

; -------------------------------------------------------------------------

prepareSwitchParseMethodItem  .macro className:str=,methodName:str=,testMethodName:str=
localLabel		.local		int
localLabel		.set		uniqueG()
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&testMethodName([CI[I[J)Z
				ifeq		falseLabel&localLabel
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&methodName([CI[I[J)I
				goto		exit
falseLabel&localLabel:				
		.mend

; -------------------------------------------------------------------------

prepareSwitchParseMethodEnd   .macro className:str=,methodName:str=
falseLabel:		iload		from
exit:			ireturn
&methodName		.end
		.mend

; -------------------------------------------------------------------------

prepareCaseTestMethodStart .macro className:str=,methodName:str=
&methodName		.method		boolean private static
content			.parameter	char[] final
from			.parameter	int
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack		optimistic
		.mend

; -------------------------------------------------------------------------

prepareCaseTestMethodItem  .macro className:str=,methodName:str=,skipMethodName:str=
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&methodName([CI[I[J)Z
				ifeq		falseLabel
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&skipMethodName([CI[I[J)I
				istore		from
		.mend

; -------------------------------------------------------------------------

prepareCaseTestMethodEnd   .macro className:str=,methodName:str=
				ldc			1
				ireturn
falseLabel:		ldc			0
				ireturn				
&methodName		.end
		.mend

; -------------------------------------------------------------------------

prepareCaseSkipMethodStart .macro className:str=,methodName:str=,testMethodName:str=
&methodName		.method		int private static
content			.parameter	char[] final
from			.parameter	int
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack		optimistic
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&testMethodName([CI[I[J)Z
				ifeq		falseLabel
		.mend

; -------------------------------------------------------------------------

prepareCaseSkipMethodItem  .macro className:str=,methodName:str=
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&methodName([CI[I[J)I
				istore		from
		.mend

; -------------------------------------------------------------------------

prepareCaseSkipMethodEnd   .macro className:str=,methodName:str=
falseLabel:		iload		from
				ireturn
&methodName		.end
		.mend


; -------------------------------------------------------------------------

prepareCaseParseMethodStart .macro className:str=,methodName:str=,testMethodName:str=
&methodName		.method		int private static
content			.parameter	char[] final
from			.parameter	int
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack		optimistic
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&testMethodName([CI[I[J)Z
				ifeq		falseLabel
		.mend

; -------------------------------------------------------------------------

prepareCaseParseMethodItem  .macro className:str=,methodName:str=
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&methodName([CI[I[J)I
				istore		from
		.mend

; -------------------------------------------------------------------------

prepareCaseParseMethodEnd   .macro className:str=,methodName:str=
falseLabel:		iload		from
				ireturn
&methodName		.end
		.mend

; -------------------------------------------------------------------------

prepareRuleTestMethodStart .macro className:str=,methodName:str=
&methodName		.method		boolean private static
content			.parameter	char[] final
from			.parameter	int
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack		optimistic
		.mend

; -------------------------------------------------------------------------

prepareRuleTestMethodItem .macro className:str=,methodName:str=,skipMethodName:str=
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&methodName([CI[I[J)Z
				ifeq		falseLabel
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&skipMethodName([CI[I[J)I
				istore		from
		.mend

; -------------------------------------------------------------------------

prepareRuleTestMethodEnd .macro className:str=,methodName:str=
				ldc			1
				ireturn
falseLabel:		ldc			0
				ireturn				
&methodName		.end
		.mend

; -------------------------------------------------------------------------

prepareRuleSkipMethodStart .macro className:str=,testMethodName:str=,methodName:str=
&methodName		.method		int private static
content			.parameter	char[] final
from			.parameter	int
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack		optimistic
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&testMethodName([CI[I[J)Z
				ifeq		falseLabel
		.mend

; -------------------------------------------------------------------------

prepareRuleSkipMethodItem .macro className:str=,methodName:str=
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&methodName([CI[I[J)I
				istore		from
		.mend

; -------------------------------------------------------------------------

prepareRuleSkipMethodEnd .macro className:str=,methodName:str=
falseLabel:		iload		from
				ireturn
&methodName		.end
		.mend

; -------------------------------------------------------------------------

prepareRuleParseMethodStart .macro className:str=,methodName:str=,testMethodName:str=,makeChildren:bool=
&methodName		.method		int private static
content			.parameter	char[] final
from			.parameter	int
names			.parameter	chav1961.purelib.basic.interfaces.SyntaxTreeInterface final
keywords		.parameter	chav1961.purelib.basic.interfaces.SyntaxTreeInterface final
root			.parameter	chav1961.purelib.cdb.SyntaxNode final
stack			.parameter	chav1961.purelib.cdb.intern.BNFParserStack final
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack	optimistic
				aload		content
				iload		from
				aload		tempInt
				aload		tempLong
				invokestatic	&testMethodName([CI[I[J)Z
				ifne		trueLabel
				aload		content
				iload		from
				ldc			" parse illegal"
				getstatic	chav1961.purelib.cdb.AbstractBNFParser.EMPTY_PARAMETERS
				invokestatic	chav1961.purelib.cdb.AbstractBNFParser.throwSyntaxException([CILjava/lang/String;[Ljava/lang/Object;)V
trueLabel:		
				.if			makeChildren
					aload		stack
					invokevirtual	chav1961.purelib.cdb.intern.BNFParserStack.push()V
				.endif						
		.mend

; -------------------------------------------------------------------------

prepareRuleParseMethodItem .macro className:str=,methodName:str=,makeChildren:bool=
				aload		content
				iload		from
				aload		names
				aload		keywords
				aload		root
				.if			makeChildren
					invokevirtual	chav1961.purelib.cdb.SyntaxNode.clone()Ljava/lang/Object;
					checkcast	chav1961.purelib.cdb.SyntaxNode
					dup
					aload		stack
					swap
					invokevirtual chav1961.purelib.cdb.intern.BNFParserStack.add(Lchav1961/purelib/cdb/SyntaxNode;)V
				.endif
				aload		stack
				aload		tempInt
				aload		tempLong
				invokestatic	&methodName([CILchav1961/purelib/basic/interfaces/SyntaxTreeInterface;Lchav1961/purelib/basic/interfaces/SyntaxTreeInterface;Lchav1961/purelib/cdb/SyntaxNode;Lchav1961/purelib/cdb/intern/BNFParserStack;[I[J)I
				istore		from
		.mend

; -------------------------------------------------------------------------

prepareRuleParseMethodEnd .macro className:str=,methodName:str=,keyword:int=,makeChildren:bool=
				.if			makeChildren
					aload	stack
					invokevirtual chav1961.purelib.cdb.intern.BNFParserStack.pop()[Lchav1961/purelib/cdb/SyntaxNode;
					dup
					dup
					arraylength
					ifeq	skipStore
					arraylength
					ldc		1
					if_icmpne	store
					aload	root
					invokestatic chav1961.purelib.cdb.AbstractBNFParser.moveContent2Root([Lchav1961/purelib/cdb/SyntaxNode;Lchav1961/purelib/cdb/SyntaxNode;)V 
					goto	exit					
store:				aload	root
					swap
					putfield	chav1961.purelib.cdb.SyntaxNode.children
					aload	root
					aload	keywords
					ldc2_w		&keyword.L
					invokeinterface	chav1961.purelib.basic.interfaces.SyntaxTreeInterface.getCargo(J)Ljava/lang/Object;
					checkcast	java.lang.Enum
					putfield	chav1961.purelib.cdb.SyntaxNode.type
					aload	root
					pop					
					goto	exit
skipStore:			pop					
					pop					
				.endif
exit:			iload		from
				ireturn
&methodName		.end				
		.mend

; -------------------------------------------------------------------------

prepareDetectedParseMethod .macro className:str=,methodName:str=,item:int=
&methodName		.method		int private static
content			.parameter	char[] final
from			.parameter	int
names			.parameter	chav1961.purelib.basic.interfaces.SyntaxTreeInterface final
keywords		.parameter	chav1961.purelib.basic.interfaces.SyntaxTreeInterface final
root			.parameter	chav1961.purelib.cdb.SyntaxNode final
stack			.parameter	chav1961.purelib.cdb.intern.BNFParserStack
tempInt			.parameter	int[] final
tempLong		.parameter	long[] final
				.stack	optimistic
				aload		root
				aload		keywords
				ldc2_w		&item.L
				invokeinterface	chav1961.purelib.basic.interfaces.SyntaxTreeInterface.getCargo(J)Ljava/lang/Object;
				checkcast	java.lang.Enum
				putfield	chav1961.purelib.cdb.SyntaxNode.type
				iload		from
				ireturn
&methodName		.end
		.mend

; -------------------------------------------------------------------------

prepareSkipInternal	.macro className:str=,testMethod:str=,skipMethod:str=
skipInternal	.method	int protected
content			.parameter	char[] final
from			.parameter	int
keywords		.parameter	chav1961.purelib.basic.interfaces.SyntaxTreeInterface final
				.stack	optimistic
				skipBlank
				aload		content
				iload		from
				aload		this
				getfield	chav1961.purelib.cdb.AbstractBNFParser.tempInt
				aload		this
				getfield	chav1961.purelib.cdb.AbstractBNFParser.tempLong
				invokestatic	&testMethod([CI[I[J)Z
				ifeq		falseLabel
				aload		content
				iload		from
				aload		this
				getfield	chav1961.purelib.cdb.AbstractBNFParser.tempInt
				aload		this
				getfield	chav1961.purelib.cdb.AbstractBNFParser.tempLong
				invokestatic	&skipMethod([CI[I[J)I
				istore		from
falseLabel:		iload		from
				ireturn
skipInternal	.end
		.mend

; -------------------------------------------------------------------------

prepareParseInternal	.macro className:str=,testMethod:str=,parseMethod:str=
parseInternal	.method	int protected
content			.parameter	char[] final
from			.parameter	int
names			.parameter	chav1961.purelib.basic.interfaces.SyntaxTreeInterface final
keywords		.parameter	chav1961.purelib.basic.interfaces.SyntaxTreeInterface final
root			.parameter	chav1961.purelib.cdb.SyntaxNode final
				.stack	optimistic
				aload		content
				iload		from
				aload		this
				getfield	chav1961.purelib.cdb.AbstractBNFParser.tempInt
				aload		this
				getfield	chav1961.purelib.cdb.AbstractBNFParser.tempLong
				invokestatic	&testMethod([CI[I[J)Z
				ifne		truelabel
				aload		content				
				iload		from
				ldc			" parse illegal"
				getstatic	chav1961.purelib.cdb.AbstractBNFParser.EMPTY_PARAMETERS
				invokestatic	chav1961.purelib.cdb.AbstractBNFParser.throwSyntaxException([CILjava/lang/String;[Ljava/lang/Object;)V
truelabel:		aload		content
				iload		from
				aload		names
				aload		keywords
				aload		root
				aload		this
				getfield	chav1961.purelib.cdb.AbstractBNFParser.stack	
				aload		this
				getfield	chav1961.purelib.cdb.AbstractBNFParser.tempInt	
				aload		this
				getfield	chav1961.purelib.cdb.AbstractBNFParser.tempLong	
				invokestatic	&parseMethod([CILchav1961/purelib/basic/interfaces/SyntaxTreeInterface;Lchav1961/purelib/basic/interfaces/SyntaxTreeInterface;Lchav1961/purelib/cdb/SyntaxNode;Lchav1961/purelib/cdb/intern/BNFParserStack;[I[J)I
				ireturn	
parseInternal	.end
		.mend

; -------------------------------------------------------------------------

endClassDeclaration	.macro className:str=
&className		.end
		.mend
