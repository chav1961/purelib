package chav1961.purelib.sql;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import chav1961.purelib.sql.interfaces.QueryExecutor;

public abstract class AbstractStatement implements Statement {
	private final Connection			conn;
	private final int					type, concurrency, holdability;
	private final List<String>			batchList = new ArrayList<>();

	protected String					cursorName = null;
	protected ResultSet					rs = null;
	protected BatchResult[]				batchResult = null;
	protected int						batchCursor = -1, updateCount = -1;
	protected boolean 					wasResultSet = false;
	
	private int							fetchDirection = ResultSet.FETCH_FORWARD, fetchSize = 1;
	private int							maxFieldSize = 0, maxRows = 0, queryTimeout = 0;
	@SuppressWarnings("unused")
	private boolean						isClosed = false, isPoolable = false, escapeProcessing = false;
	
	public AbstractStatement(final Connection conn, final int type, final int concurrency, final int holdability) {
		if (conn == null) {
			throw new NullPointerException("Connection can't be null");
		}
		else if (type != ResultSet.TYPE_FORWARD_ONLY && type != ResultSet.TYPE_SCROLL_INSENSITIVE && type != ResultSet.TYPE_SCROLL_SENSITIVE) {
			throw new IllegalArgumentException("Illegal statement type ["+type+"]. Only [TYPE_FORWARD_ONLY], [TYPE_SCROLL_INSENSITIVE] and [TYPE_SCROLL_SENSITIVE] are available");
		}
		else if (concurrency != ResultSet.CONCUR_READ_ONLY && concurrency != ResultSet.CONCUR_UPDATABLE) {
			throw new IllegalArgumentException("Illegal concurrency type ["+concurrency+"]. Only [CONCUR_READ_ONLY] and [CONCUR_UPDATABLE] are available");
		}
		else if (holdability != ResultSet.HOLD_CURSORS_OVER_COMMIT && holdability != ResultSet.CLOSE_CURSORS_AT_COMMIT) {
			throw new IllegalArgumentException("Illegal holdability ["+holdability+"]. Only [HOLD_CURSORS_OVER_COMMIT] and [CLOSE_CURSORS_AT_COMMIT] are available");
		}
		else {
			this.conn = conn;
			this.type = type;
			this.concurrency = concurrency;
			this.holdability = holdability;
		}
	}

	protected abstract QueryExecutor createQueryExecutor(final String sql) throws SQLException;
	
	@Override
	public boolean isWrapperFor(final Class<?> iface) throws SQLException {
		if (iface == null) {
			throw new NullPointerException("Interface to check can't be null");
		}
		else {
			return iface.isAssignableFrom(this.getClass());
		}
	}

	@Override
	public <T> T unwrap(final Class<T> iface) throws SQLException {
		if (iface == null) {
			throw new NullPointerException("Interface to check can't be null");
		}
		else if (!isWrapperFor(iface)) {
			throw new NullPointerException("This instance can't be casted to awaited class ["+iface+"]");
		}
		else {
			return iface.cast(this);
		}
	}

	@Override
	public void addBatch(final String batch) throws SQLException {
		if (batch == null || batch.isEmpty()) {
			throw new IllegalArgumentException("Batch string can't be null or empty");
		}
		else {
			batchList.add(batch);
		}
	}

	@Override
	public void cancel() throws SQLException {
	}

	@Override
	public void clearBatch() throws SQLException {
		batchList.clear();
		batchResult = null;
	}

	@Override
	public void clearWarnings() throws SQLException {
	}

	@Override
	public void close() throws SQLException {
		isClosed = true;
	}

	@Override
	public void closeOnCompletion() throws SQLException {
		testClosing();
	}

	@Override
	public boolean execute(final String sql) throws SQLException {
		testClosing();
		if (sql == null || sql.isEmpty()) {
			throw new IllegalArgumentException("SQL string to execute can't be null or empty"); 
		}
		else if (isThisAQueryString(sql)) {
			rs = executeQuery(sql);
			return wasResultSet = true;
		}
		else {
			updateCount = executeUpdate(sql);
			return wasResultSet = false;
		}
	}

	@Override
	public boolean execute(final String sql, final int autoGeneratedKeys) throws SQLException {
		testClosing();
		if (sql == null || sql.isEmpty()) {
			throw new IllegalArgumentException("SQL string to execute can't be null or empty"); 
		}
		else if (isThisAQueryString(sql)) {
			rs = executeQuery(sql);
			return wasResultSet = true;
		}
		else {
			updateCount = executeUpdate(sql,autoGeneratedKeys);
			return wasResultSet = false;
		}
	}

	@Override
	public boolean execute(final String sql, final int[] columnIndexes) throws SQLException {
		testClosing();
		if (sql == null || sql.isEmpty()) {
			throw new IllegalArgumentException("SQL string to execute can't be null or empty"); 
		}
		else if (isThisAQueryString(sql)) {
			rs = executeQuery(sql);
			return wasResultSet = true;
		}
		else {
			updateCount = executeUpdate(sql,columnIndexes);
			return wasResultSet = false;
		}
	}

	@Override
	public boolean execute(final String sql, final String[] columnNames) throws SQLException {
		testClosing();
		if (sql == null || sql.isEmpty()) {
			throw new IllegalArgumentException("SQL string to execute can't be null or empty"); 
		}
		else if (isThisAQueryString(sql)) {
			rs = executeQuery(sql);
			return wasResultSet = true;
		}
		else {
			updateCount = executeUpdate(sql,columnNames);
			return wasResultSet = false;
		}
	}

	@Override
	public int[] executeBatch() throws SQLException {
		testClosing();
		final int[]		result = new int[batchList.size()];
		
		batchResult	= new BatchResult[result.length];
		for (int index = 0; index < result.length; index++) {
			final String	sql = batchList.get(index);
		
			if (isThisAQueryString(sql)) {
				try{batchResult[index] = new BatchResult(executeQuery(sql));
					result[index] = SUCCESS_NO_INFO;
				} catch (SQLException exc) {
					result[index] = EXECUTE_FAILED;
				}
			}
			else {
				try{batchResult[index] = new BatchResult(executeUpdate(sql));
					result[index] = batchResult[index].updateCount;
				} catch (SQLException exc) {
					result[index] = EXECUTE_FAILED;
				}
			}
		}
		batchCursor = 0;
		return result;
	}

	@Override
	public ResultSet executeQuery(final String sql) throws SQLException {
		testClosing();
		if (sql == null || sql.isEmpty()) {
			throw new IllegalArgumentException("Sql string to execute can't be null or empty");
		}
		else {
			final QueryExecutor	sqe = createQueryExecutor(sql);
			
			return new InMemoryReadOnlyResultSet(this,sqe.getRsMetaData(),getResultSetType(),new ArrayContent(sqe.executeQuery()));
		}
	}

	@Override
	public int executeUpdate(final String sql) throws SQLException {
		testClosing();
		throw new SQLFeatureNotSupportedException("Read-only fsys!");
	}

	@Override
	public int executeUpdate(final String sql, final int autoGeneratedKeys) throws SQLException {
		testClosing();
		throw new SQLFeatureNotSupportedException("Call with autogenerated keys is not supported");
	}

	@Override
	public int executeUpdate(final String sql, final int[] columnIndex) throws SQLException {
		testClosing();
		throw new SQLFeatureNotSupportedException("Call with autogenerated keys is not supported");
	}

	@Override
	public int executeUpdate(final String sql, final String[] columnNames) throws SQLException {
		testClosing();
		throw new SQLFeatureNotSupportedException("Call with autogenerated keys is not supported");
	}

	@Override
	public Connection getConnection() throws SQLException {
		return conn;
	}

	@Override
	public int getFetchDirection() throws SQLException {
		return fetchDirection;
	}

	@Override
	public int getFetchSize() throws SQLException {
		return fetchSize;
	}

	@Override
	public ResultSet getGeneratedKeys() throws SQLException {
		testClosing();
		throw new SQLFeatureNotSupportedException("Call with autogenerated keys is not supported");
	}

	@Override
	public int getMaxFieldSize() throws SQLException {
		return maxFieldSize;
	}

	@Override
	public int getMaxRows() throws SQLException {
		return maxRows;
	}

	@Override
	public boolean getMoreResults() throws SQLException {
		return getMoreResults(Statement.CLOSE_CURRENT_RESULT);
	}

	@Override
	public boolean getMoreResults(final int action) throws SQLException {
		if (action != CLOSE_CURRENT_RESULT && action != CLOSE_ALL_RESULTS && action != KEEP_CURRENT_RESULT) {
			throw new IllegalArgumentException("Illegal action ["+action+"]. Only [CLOSE_CURRENT_RESULT], [CLOSE_ALL_RESULTS] and [KEEP_CURRENT_RESULT] are available");
		}
		else if (batchResult != null) {
			if (batchCursor >= batchResult.length) {
				batchResult = null;
				wasResultSet = false;
				return false;
			}
			else if (batchResult[batchCursor] == null) {
				return false;
			}
			else if (batchResult[batchCursor].isQuery) {
				switch (action) {
					case CLOSE_CURRENT_RESULT	:
						getResultSet().close();
						break;
					case CLOSE_ALL_RESULTS		:
						for (int index = batchCursor; index < batchResult.length; index++) {
							if (batchResult[batchCursor].isQuery) {
								batchResult[batchCursor].rs.close();
							}
						}
						break;
					case KEEP_CURRENT_RESULT	:
						break;
					default : throw new UnsupportedOperationException("Action ["+action+"] is not supported yet");  
				}
				batchCursor++;
				return batchResult[batchCursor] != null && batchResult[batchCursor].isQuery;
			}
			else {
				batchCursor++;
				return batchResult[batchCursor] != null;
			}
		}
		else {
			return false;
		}
	}

	@Override
	public int getQueryTimeout() throws SQLException {
		return queryTimeout;
	}

	@Override
	public ResultSet getResultSet() throws SQLException {
		testClosing();
		if (batchResult != null) {
			return batchResult[batchCursor] != null && batchResult[batchCursor].isQuery ? batchResult[batchCursor].rs : null; 
		}
		else {
			return wasResultSet ? rs : null;
		}
	}

	@Override
	public int getResultSetConcurrency() throws SQLException {
		return concurrency;
	}

	@Override
	public int getResultSetHoldability() throws SQLException {
		return holdability;
	}

	@Override
	public int getResultSetType() throws SQLException {
		return type;
	}

	@Override
	public int getUpdateCount() throws SQLException {
		testClosing();
		if (batchResult != null) {
			return batchResult[batchCursor] != null && !batchResult[batchCursor].isQuery ? batchResult[batchCursor].updateCount : 0; 
		}
		else {
			return wasResultSet ? -1 : updateCount;
		}
	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		return null;
	}

	@Override
	public boolean isCloseOnCompletion() throws SQLException {
		return false;
	}

	@Override
	public boolean isClosed() throws SQLException {
		return isClosed;
	}

	@Override
	public boolean isPoolable() throws SQLException {
		return isPoolable;
	}

	@Override
	public void setCursorName(final String cursorName) throws SQLException {
		this.cursorName = cursorName;
	}

	@Override
	public void setEscapeProcessing(final boolean escapeProcessing) throws SQLException {
		this.escapeProcessing = escapeProcessing;
	}

	@Override
	public void setFetchDirection(final int fetchDirection) throws SQLException {
		if (fetchDirection != ResultSet.FETCH_FORWARD && fetchDirection != ResultSet.FETCH_REVERSE) {
			throw new IllegalArgumentException("Illegal fetch direction ["+fetchDirection+"]. Only [FETCH_FORWARD] and [FETCH_REVERSE] are available");
		}
		else {
			this.fetchDirection = fetchDirection;
		}
	}

	@Override
	public void setFetchSize(final int fetchSize) throws SQLException {
		if (fetchSize <= 0) {
			throw new IllegalArgumentException("Fetch size ["+fetchSize+"] need be greater than 0");
		}
		else {
			this.fetchSize = fetchSize;
		}
	}

	@Override
	public void setMaxFieldSize(final int maxFieldSize) throws SQLException {
		if (maxFieldSize < 0) {
			throw new IllegalArgumentException("Max field size ["+maxFieldSize+"] can't be negative");
		}
		else {
			this.maxFieldSize = maxFieldSize;
		}
	}

	@Override
	public void setMaxRows(final int maxRows) throws SQLException {
		if (maxRows < 0) {
			throw new IllegalArgumentException("Max rows ["+maxRows+"] can't be negative");
		}
		else {
			this.maxRows = maxRows;
		}
	}

	@Override
	public void setPoolable(final boolean poolable) throws SQLException {
		this.isPoolable = poolable;
	}

	@Override
	public void setQueryTimeout(final int timeout) throws SQLException {
		if (timeout < 0) {
			throw new IllegalArgumentException("Query timeout ["+timeout+"] can't be negative");
		}
		else {
			this.queryTimeout = timeout;
		}
	}
	
	protected boolean isThisAQueryString(final String sql) throws SQLException {
		return false;
	}
	
	protected void testClosing() throws SQLException{
		if (isClosed()) {
			throw new SQLException("Attempt to call this method on the closed statement");
		}
	}

	protected static class BatchResult {
		final boolean	isQuery;
		final int		updateCount;
		final ResultSet	rs;
		
		BatchResult(final int updateCount) {
			this.isQuery = false;
			this.updateCount = updateCount;
			this.rs = null;
		}
		
		BatchResult(final ResultSet rs) {
			this.isQuery = true;
			this.updateCount = -1;
			this.rs = rs;
		}
	}
}
